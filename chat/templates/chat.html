<!DOCTYPE html>
<html lang="en">
{% load static %}

<head>
  <link rel="icon" href="{% static 'chat/favicon.ico' %}" type="image/x-icon">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <audio id="ringtone" src="{% static 'audio/ringtone.mp3' %}" preload="auto"></audio>
  <script src="https://cdn.jsdelivr.net/npm/recorder-js@latest/dist/recorder.js"></script>
  <title>Chat Application</title>
  <style>
    .navbar {
      padding-top: 0.25rem;
      padding-bottom: 0.25rem;
      min-height: 40px;
    }

    .navbar-brand {
      font-size: 1rem;
      padding: 0.25rem 0.5rem;
    }

    .navbar .form-select,
    .navbar .btn {
      font-size: 0.875rem;
      padding: 0.25rem 0.5rem;
      height: auto;
    }

    .chat-box {
      height: 400px;
      overflow-y: auto;
      border-radius: 8px;
      background-color: #f8f9fa;
    }

    .user-card.selected {
      background-color: #e0f7fa;
      border-left: 4px solid #00bcd4;
    }

    #remoteAudio {
      display: none;
    }

    #inviteBox .alert {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* Modal backdrop */
    .modal {
      position: absolute;
      top: 25%;
      left: 25%;
      width: 50vw;
      height: 50vh;
      background: rgba(0, 0, 0, 0.6);
      /* dimmed overlay */
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    /* Hide by default */
    .hidden {
      display: none !important;
    }

    /* Modal content box */
    .modal-content {
      background: #fff;
      padding: 2rem;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3);
      text-align: center;
      animation: fadeIn 0.3s ease-in-out;
    }

    /* Title */
    .modal-content h3 {
      margin-bottom: 1rem;
      font-size: 1.5rem;
      color: #333;
    }

    /* Info text */
    .modal-content p {
      margin: 0.5rem 0;
      font-size: 1rem;
      color: #555;
    }

    /* Buttons */
    #accept-invite-btn,
    #decline-invite-btn {
      margin: 1rem 0.5rem 0;
      padding: 0.6rem 1.2rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    #accept-invite-btn {
      background-color: #4caf50;
      color: white;
    }

    #accept-invite-btn:hover {
      background-color: #43a047;
    }

    #decline-invite-btn {
      background-color: #f44336;
      color: white;
    }

    #decline-invite-btn:hover {
      background-color: #e53935;
    }

    /* Fade-in animation */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }
  </style>
</head>

<body>
  <nav class="navbar navbar-light" style="background-color: #e3f2fd;">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Chat App</a>

      <div class="d-flex">
        <select id="languageSelect" class="form-select form-select-sm" style="width: 160px;"
          onchange="changeLanguage(this.value)">
          <option value="en">English</option>
          <option value="hi">Hindi (‡§π‡§ø‡§Ç‡§¶‡•Ä)</option>
          <option value="mr">Marathi (‡§Æ‡§∞‡§æ‡§†‡•Ä)</option>
          <option value="fr">French (Fran√ßais)</option>
          <option value="es">Spanish (Espa√±ol)</option>
          <option value="ja">Japanese (Êó•Êú¨Ë™û)</option>
        </select>
        <button id="startCall" class="btn btn-outline-success me-2" style="display: none;">üé§ Start Voice Call</button>
        <button id="pollForCall" style="display: none;" class="btn btn-outline-success me-2">Check Incoming
          Call</button>
        <button id="startMeetingBtn" class="btn btn-outline-primary me-2">üìû Start Group Call</button>
        <button id="stopCall" class="btn btn-outline-secondary me-2">üõë Stop Call</button>
        <a href="{% url 'login' %}" class="btn btn-outline-danger">üö™ Logout</a>
        <div class="modal fade" id="incomingCallModal" tabindex="-1" aria-labelledby="incomingCallLabel"
          aria-hidden="false">
          <div class="modal-dialog modal-dialog-bottom-end">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title" id="incomingCallLabel">üìû Incoming Call</h5>
              </div>
              <div class="modal-body">
                You have an incoming call. Do you want to pick up?
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-success" id="pickupBtn">Pick Up</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </nav>
  <div class="container mt-4">
    <div class="row">
      <!-- User List -->
      <div class="col-md-4">
        <div class="card">
          <div class="card-header text-center">
            <h4>Connected Users</h4>
          </div>
          <div class="card-body">
            <ul class="list-group">
              {% for user in users %}
              <li class="list-group-item user-card" data-userid="{{ user.id }}">
                <a href="{% url 'chat' user.id %}">{{ user.username }}</a>
                <button class="btn btn-sm float-end btn-light" onclick="selectAndStartCall(this)">üìû</button>
              </li>
              {% empty %}
              <li class="list-group-item text-muted text-center">No users available.</li>
              {% endfor %}
            </ul>
          </div>
        </div>
      </div>
      <!-- Chat Box -->
      <div class="col-md-8">
        <div class="card">
          <div class="card-header text-center">
            <h4>Chat with {{ receiver.username }}</h4>
          </div>
          <div class="card-body">
            <div class="chat-box" id="chatbox">
              {% for chat in chat_history %}
              <p><strong>{{ chat.sender.username }}</strong>: {{ chat.message }}</p>
              {% endfor %}
            </div>
            <form id="chatForm" method="POST" class="mt-3">
              {% csrf_token %}
              <div class="input-group">
                <input type="text" id="messageInput" name="message" class="form-control"
                  placeholder="Type your message...">
                <button type="button" id="sendMessage" class="btn btn-primary">Send</button>
              </div>
            </form>
          </div>
        </div>
      </div>
      <!-- <div id="inviteBox" class="mt-3"></div> -->
    </div>
  </div>
  <div id="invite-modal" class="modal hidden">
    <div class="modal-content">
      <h3>üìû Incoming Meeting Invite</h3>
      <p><strong>From:</strong> <span id="inviter-name"></span>
        <strong>Room:</strong> <span id="invite-room"></span>
      </p>
      <button id="accept-invite-btn" calss="btn btn-outline-primary">Accept</button>
      <button id="decline-invite-btn" calss="btn btn-outline-danger">Reject</button>
    </div>
  </div>
  <script>
    function loadChatHistory() {
      const receiver = "{{ receiver.id }}";
      //console.log('After Call : ', receiver)
      fetch(`/chat/load/?receiver=${receiver}`, { cache: "no-store" })
        .then(response => response.json())
        .then(data => {
          const chatBox = document.getElementById("chatbox");
          chatBox.innerHTML = "";

          data.messages.forEach(msg => {
            const msgDiv = document.createElement("div");
            msgDiv.classList.add("message");

            if (msg.sender === "{{ request.user.username }}") {
              msgDiv.classList.add("sent");
            } else {
              msgDiv.classList.add("received");
            }
            msgDiv.innerHTML = `
                    <strong>${msg.sender}</strong> <small>${msg.timestamp}</small> : ${msg.content}
                `;
            chatBox.appendChild(msgDiv);
          });

          chatBox.scrollTop = chatBox.scrollHeight;
        });
    }

    document.addEventListener("DOMContentLoaded", function () {
      loadChatHistory();
      setInterval(loadChatHistory, 2000);
    });
  </script>


  <audio id="remoteAudio" autoplay playsinline muted="false" style="display: none;"></audio>
  <audio id="translatedAudio" controls></audio>
  <input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const startCall = document.getElementById("startCall");
      const pickupBtn = document.getElementById("pickupBtn");
      const ringtone = document.getElementById("ringtone");
      const modalElement = document.getElementById("incomingCallModal");
      const modalEl = new bootstrap.Modal(modalElement);
      document.getElementById("stopCall").addEventListener("click", stopCall);
      const notificationSocket = new WebSocket(`ws://${window.location.host}/ws/notifications/`);
      const modalInvite = document.getElementById("invite-modal");
      const acceptBtn = document.getElementById("accept-invite-btn");
      const declineBtn = document.getElementById("decline-invite-btn");

      let localStream = null;
      let latestOffer = null;
      let currentCallId = null;
      let callInProgress = false;
      let lastOfferId = null;
      let peerConnection = null;
      let micTrack = null;
      let tracks = null;
      let testStream = null;
      let textToBeSent = null;
      let recorder = null;
      let receiver = "{{ receiver.id }}";


      notificationSocket.onopen = () => {
        console.log("üîî Notification WebSocket connected");
      };

      notificationSocket.onmessage = (event) => {
        const data = JSON.parse(event.data);
        console.log("üì® notificationSocket.onmessage data.type :", data.type);

        if (data.type === "receive_invite") {
          showInviteModal({
            inviterId: data.from,
            roomName: data.room
          });
        }
      };

      function showInviteModal(roomName, inviterId) {
        inviterId = roomName.inviterId;
        roomName = roomName.roomName
        const modal = document.getElementById("invite-modal");
        const nameSpan = document.getElementById("inviter-name");
        const roomSpan = document.getElementById("invite-room");
        console.log("inviter-name and invite-room")

        if (!modal || !nameSpan || !roomSpan) {
          console.error("‚ùå Modal or content elements not found.");
          return;
        }

        nameSpan.textContent = inviterId;
        roomSpan.textContent = roomName;

        modal.classList.remove("hidden");

        if (acceptBtn && declineBtn) {
          acceptBtn.onclick = () => {
            const room = document.getElementById("invite-room").textContent;
            window.location.href = `/meeting/${room}/`;
          };

          declineBtn.onclick = () => {
            document.getElementById("invite-modal").classList.add("hidden");
          };
        } else {
          console.warn("‚ùå Invite buttons not found in DOM.");
        }
      }

      function getCSRFToken() {
        return document.cookie.split("; ").find(row => row.startsWith("csrftoken="))?.split("=")[1];
      }

      async function prepareMicTrack() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const audioTracks = stream.getAudioTracks();

          if (!audioTracks || audioTracks.length === 0) {
            console.warn("‚ö†Ô∏è No audio tracks found");
            return;
          }

          micTrack = audioTracks[0];
          console.log("üé§ Mic track ready:", micTrack);
        } catch (err) {
          console.error("üö´ getUserMedia failed:", err);
        }
      }

      async function getCurrentUserId() {
        try {
          const response = await fetch("/api/me", { credentials: "include" });
          if (!response.ok) return null;
          const data = await response.json();
          return data.id;
        } catch (err) {
          console.error("‚ùå Failed to get current user:", err);
          return null;
        }
      }

      function setupPeerConnection() {
        const pc = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" },
          {
            urls: "turn:relay.example.com:3478",
            username: "user",
            credential: "pass"
          }
          ]
        });
        // üîÑ Monitor connection state
        pc.onconnectionstatechange = () => {
          console.log("üîÑ Connection state:", pc.connectionState);
        };

        // üßä ICE connection status
        pc.oniceconnectionstatechange = () => {
          console.log("üßä ICE state:", pc.iceConnectionState);
        };

        // üì° ICE gathering status
        pc.onicegatheringstatechange = () => {
        };

        // ‚ùÑÔ∏è ICE candidate logs
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            console.log("‚ùÑÔ∏è ICE candidate:", event.candidate.candidate);
          } else {
            //console.log("‚úÖ ICE gathering complete");
          }
        };

        pc.ontrack = (event) => {
          // Log track state immediately
          console.log("üéôÔ∏è Incoming track:", event.track.kind);
          console.log("üîé Track muted:", event.track.muted, "| enabled:", event.track.enabled);


          if (!event.streams || event.streams.length === 0) {
            console.warn("‚ö†Ô∏è No streams in ontrack event");
            const fallbackStream = new MediaStream([event.track]);
            const remoteAudio = document.getElementById("remoteAudio");
            remoteAudio.srcObject = fallbackStream;
            remoteAudio.muted = false;
            remoteAudio.play().catch(err => {
              console.warn("üîá Autoplay blocked:", err);
            });
            return;
          }

          // ‚úÖ Normal path when streams are present
          const remoteStream = new MediaStream();
          event.streams[0].getAudioTracks().forEach(track => {
            remoteStream.addTrack(track);
            console.log("üéß Track received:", track.id, "| enabled:", track.enabled, "| muted:", track.muted);
          });

          const remoteAudio = document.getElementById("remoteAudio");
          remoteAudio.srcObject = remoteStream;
          remoteAudio.muted = false;
          remoteAudio.play().then(() => {
            console.log("üîä Remote audio playing");
          }).catch(err => {
            console.warn("üîá Autoplay blocked:", err);
          });
        };

        pc.onicecandidate = (event) => {
          if (event.candidate) {
            //console.log("üßä ICE candidate:", event.candidate);
          }
        };

        pc.onconnectionstatechange = () => {
          console.log("üîÑ Connection state:", pc.connectionState);
        };

        return pc;
      }

      startCall.onclick = async () => {
        try {
          const callerId = await getCurrentUserId();
          if (!callerId) return alert("Unable to identify caller.");

          const selectedCard = document.querySelector('.user-card.selected');
          if (!selectedCard) return alert("Please select a user to call.");

          const receiverId = selectedCard.dataset.userid;

          // Prepare local audio stream
          const localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

          // Set up peer connection
          peerConnection = setupPeerConnection();

          // Add tracks to connection and log them
          localStream.getAudioTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
            console.log("üì° Caller sending track:", track.id, "| muted:", track.muted);
          });

          // Optional test stream for debugging
          const testStream = new MediaStream([localStream.getAudioTracks()[0]]);
          console.log("üé§ Mic stream prepared:", testStream);

          // Create and send SDP offer
          const offer = await peerConnection.createOffer();
          await peerConnection.setLocalDescription(offer);

          const response = await fetch("/api/call/start", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": getCSRFToken()
            },
            body: JSON.stringify({
              caller: callerId,
              receiver: receiverId,
              sdp_offer: JSON.stringify(offer)
            })
          });

          const data = await response.json();
          currentCallId = data.id;
          console.log("üì° Outgoing call ID:", currentCallId);

        } catch (err) {
          console.error("Error starting call:", err);
        }
      };

      setInterval(async () => {
        if (callInProgress) return;

        try {
          const currentUserId = await getCurrentUserId();
          sessionStorage.setItem("currentUserId", currentUserId);
          if (!currentUserId) return;

          const res = await fetch(`/api/call/offer?for_user=${currentUserId}`);

          if (res.status !== 200) return;

          const data = await res.json();

          if (!data?.sdp_offer || !data.id || data.sdp_offer === "test-offer") return;
          if (data.id === lastOfferId) return;

          lastOfferId = data.id;
          currentCallId = data.id;
          latestOffer = data.sdp_offer;
          callInProgress = true;

          modalEl.show();
          modalEl.setAttribute("aria-hidden", "false");
          ringtone?.play().catch(() => { });
          pickupBtn.focus();

        } catch (err) {
          console.error("Polling error:", err);
        }
      }, 5000);

      async function startRecording() {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const mimeType = [
          "audio/webm;codecs=opus",
          "audio/webm",         // fallback
          "audio/ogg;codecs=opus"
        ].find(type => MediaRecorder.isTypeSupported(type));

        if (!mimeType) {
          alert("No supported audio format found for MediaRecorder");
          return;
        }

        recorder = new MediaRecorder(stream, { mimeType });
        recorder.ondataavailable = e => {
          if (e.data.size > 0) chunks.push(e.data);
        };
        chunks = [];
        recorder.onstop = () => {
          const blob = new Blob(chunks, { type: mimeType });

          uploadAudio(blob);
        };
        recorder.start();
      }

      pickupBtn.onclick = async () => {
        try {
          await startRecording();

          setTimeout(() => {
            if (recorder && recorder.state === "recording") {
              recorder.stop();
              console.log("Recording stopped.");
            }
          }, 5000);
          const popupEl = document.getElementById("incomingCallModal");
          const modalInstance = bootstrap.Modal.getInstance(popupEl);
          if (modalInstance) {
            modalInstance.hide();
          } else {
            popupEl.style.display = "none";
          }

          const inputEl = document.getElementById("messageInput");
          if (inputEl) inputEl.focus();

        } catch (err) {
          console.error("Pickup failed:", err);
        }
      };

      function uploadAudio(blob) {

        //console.log("In uploadAudio...");
        const formData = new FormData();
        formData.append("audio", blob, "speech.ogg");
        //console.log(" Uploading Audio...");
        fetch("/translate-audio/", {
          method: "POST",
          body: formData
        })
          .then(res => res.json())
          .then(data => {
            console.log("Transcribed:", data.transcribed);
            console.log("Translated:", data.translated);
            console.log("audio_url:", data.audio_url);
            textToBeSent = data.translated;
            const audio = new Audio(data.audio_url);
            audio.play();
            console.log("Translated YYY:", textToBeSent);
            saveMessageAJAX()
          })
          .catch(err => console.error("Upload failed:", err));
      }

      function saveMessageAJAX() {
        const message = textToBeSent.trim();
        const receiverId = "{{ receiver.id }}";

        if (!message) return;

        fetch("/api/chat/save/", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": document.querySelector('[name=csrfmiddlewaretoken]').value
          },
          body: JSON.stringify({
            receiver_id: receiverId,
            message: message
          })
        })
          .then(response => response.json())
          .then(data => {
            if (data.status === "Message saved") {
              console.log("Message saved:", data);
              messageInput.value = "";
              loadChatHistory();
            } else {
              console.error("Error:", data.error);
            }
          })
          .catch(error => console.error("Request failed:", error));
      }

      document.addEventListener("DOMContentLoaded", function () {
        document.getElementById("sendMessage").addEventListener("click", saveMessageAJAX);
      });

      function sendTranlatedtextToUser() {
        //console.log("Translated XXX:", textToBeSent);
        let userId = "{{ receiver.id }}"
        //const messageInput = document.getElementById("message");
        const message = textToBeSent.trim();
        console.log("userId :", userId);
        if (message !== "") {
          fetch("/api/chat/send/", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ "room_name": "{{ userId }}", "message": message })
          })
            .then(response => response.json())
            .then(data => {
              console.log("data.status :", data.status);
              messageInput.value = "";  // Clear input after sending
            });
        }
        console.log("message XXX:", message);
      }

      document.body.addEventListener("click", () => {
        if (micTrack instanceof MediaStreamTrack) {
          const testStream = new MediaStream([micTrack]); // ‚úÖ No TypeError

          const audio = document.createElement("audio");
          audio.srcObject = testStream;
          audio.autoplay = true;
          audio.playsInline = true;
          audio.volume = 1.0;
          document.body.appendChild(audio);

          console.log("Mic playback triggered");
        } else {
          console.warn("Mic track is invalid or not yet ready");
        }
      }, { once: true }); // Runs only once to avoid re-adding audio

      function stopCall() {
        console.log("Stopping call...");

        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
        }

        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }

        if (recorder && recorder.stop) {
          recorder.stop();
          recorder = null;
        }

        document.getElementById("stopCall").style.display = "none";
        document.querySelectorAll('.user-card').forEach(card =>
          card.classList.remove('selected')
        );
        const ringtone = document.getElementById("ringtone");
        if (ringtone) ringtone.pause();

        const remoteAudio = document.getElementById("remoteAudio");
        if (remoteAudio) remoteAudio.srcObject = null;
      }
    });

  </script>
  <script>
    function selectUser(button) {
      document.querySelectorAll('.user-card').forEach(card =>
        card.classList.remove('selected')
      );

      const card = button.closest('.user-card');
      if (card) {
        card.classList.add('selected');
      } else {
        console.warn("Could not find user-card for clicked button");
      }
    }

    function selectAndStartCall(button) {
      selectUser(button);

      const startCallBtn = document.getElementById("startCall");
      if (startCallBtn) {
        startCallBtn.click();
      } else {
        console.warn("Start Call button not found in DOM");
      }
    }

    document.getElementById("startMeetingBtn").addEventListener("click", () => {
      //startGroupCall(); // This is fine because it's not using await here
      const roomName = `room_${Date.now()}`;
      const receiverId = "{{ receiver.id }}";
      const vtag = "chat"
      fetch("/api/send-meeting-invite/", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ room: roomName, target: receiverId, tag: vtag })
      }).then(() => {
        window.location.href = `/meeting/${roomName}/`;
      });
    });

    function changeLanguage(lang) {
      sessionStorage.setItem("targetLang", lang);

      const currentUserId = sessionStorage.getItem("currentUserId");
      console.log("üåç Language preference saved:", lang, currentUserId);
      fetch("/set_language", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userId: currentUserId, language: lang })
      }).then(() => {
        console.log("üåç Language preference saved:", lang);
      });

      console.log("üåç Language selected:", lang);
    }

  </script>
</body>

</html>