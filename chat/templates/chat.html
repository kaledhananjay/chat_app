<!DOCTYPE html>
<html lang="en">
{% load static %}

<head>
  <link rel="icon" href="{% static 'chat/favicon.ico' %}" type="image/x-icon">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <audio id="ringtone" src="{% static 'audio/ringtone.mp3' %}" preload="auto"></audio>
  <script src="https://cdn.jsdelivr.net/npm/recorder-js@latest/dist/recorder.js"></script>
  <title>Chat Application</title>
  <style>
    .navbar {
      padding-top: 0.25rem;
      padding-bottom: 0.25rem;
      min-height: 40px;
    }

    .navbar-brand {
      font-size: 1rem;
      padding: 0.25rem 0.5rem;
    }

    .navbar .form-select,
    .navbar .btn {
      font-size: 0.875rem;
      padding: 0.25rem 0.5rem;
      height: auto;
    }

    .chat-box {
      height: 400px;
      overflow-y: auto;
      border-radius: 8px;
      background-color: #f8f9fa;
    }

    .user-card.selected {
      background-color: #e0f7fa;
      border-left: 4px solid #00bcd4;
    }

    #remoteAudio {
      display: none;
    }

    #inviteBox .alert {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
  </style>
</head>

<body>
  <nav class="navbar navbar-light" style="background-color: #e3f2fd;">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Chat App</a>

      <div class="d-flex">
        <select id="languageSelect" class="form-select form-select-sm" style="width: 160px;"
          onchange="changeLanguage(this.value)">
          <option value="en">English</option>
          <option value="hi">Hindi (à¤¹à¤¿à¤‚à¤¦à¥€)</option>
          <option value="mr">Marathi (à¤®à¤°à¤¾à¤ à¥€)</option>
          <option value="fr">French (FranÃ§ais)</option>
          <option value="es">Spanish (EspaÃ±ol)</option>
        </select>
        <button id="startCall" class="btn btn-outline-success me-2" style="display: none;">ðŸŽ¤ Start Voice Call</button>
        <button id="pollForCall" style="display: none;" class="btn btn-outline-success me-2">Check Incoming
          Call</button>
        <button id="startMeetingBtn" class="btn btn-outline-primary me-2">ðŸ“ž Start Group Call</button>
        <button id="stopCall" class="btn btn-outline-secondary me-2">ðŸ›‘ Stop Call</button>
        <a href="{% url 'login' %}" class="btn btn-outline-danger">ðŸšª Logout</a>
        <div class="modal fade" id="incomingCallModal" tabindex="-1" aria-labelledby="incomingCallLabel"
          aria-hidden="true">
          <div class="modal-dialog modal-dialog-bottom-end">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title" id="incomingCallLabel">ðŸ“ž Incoming Call</h5>
              </div>
              <div class="modal-body">
                You have an incoming call. Do you want to pick up?
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-success" id="pickupBtn">Pick Up</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </nav>
  <div class="container mt-4">
    <div class="row">
      <!-- User List -->
      <div class="col-md-4">
        <div class="card">
          <div class="card-header text-center">
            <h4>Connected Users</h4>
          </div>
          <div class="card-body">
            <ul class="list-group">
              {% for user in users %}
              <li class="list-group-item user-card" data-userid="{{ user.id }}">
                <a href="{% url 'chat' user.id %}">{{ user.username }}</a>
                <button class="btn btn-sm float-end btn-light" onclick="selectAndStartCall(this)">ðŸ“ž</button>
              </li>
              {% empty %}
              <li class="list-group-item text-muted text-center">No users available.</li>
              {% endfor %}
            </ul>
          </div>
        </div>
      </div>
      <!-- Chat Box -->
      <div class="col-md-8">
        <div class="card">
          <div class="card-header text-center">
            <h4>Chat with {{ receiver.username }}</h4>
          </div>
          <div class="card-body">
            <div class="chat-box" id="chatbox">
              {% for chat in chat_history %}
              <p><strong>{{ chat.sender.username }}</strong>: {{ chat.message }}</p>
              {% endfor %}
            </div>
            <form id="chatForm" method="POST" class="mt-3">
              {% csrf_token %}
              <div class="input-group">
                <input type="text" id="messageInput" name="message" class="form-control"
                  placeholder="Type your message...">
                <button type="button" id="sendMessage" class="btn btn-primary">Send</button>
              </div>
            </form>
          </div>
        </div>
      </div>
      <div id="inviteBox" class="mt-3"></div>
    </div>
  </div>
  <script>
    function loadChatHistory() {
      const receiver = "{{ receiver.id }}";
      console.log('After Call : ', receiver)
      fetch(`/chat/load/?receiver=${receiver}`, { cache: "no-store" })
        .then(response => response.json())
        .then(data => {
          const chatBox = document.getElementById("chatbox");
          chatBox.innerHTML = "";

          data.messages.forEach(msg => {
            const msgDiv = document.createElement("div");
            msgDiv.classList.add("message");

            if (msg.sender === "{{ request.user.username }}") {
              msgDiv.classList.add("sent");
            } else {
              msgDiv.classList.add("received");
            }
            msgDiv.innerHTML = `
                    <strong>${msg.sender}</strong> <small>${msg.timestamp}</small> : ${msg.content}
                `;
            chatBox.appendChild(msgDiv);
          });

          chatBox.scrollTop = chatBox.scrollHeight;
        });
    }

    document.addEventListener("DOMContentLoaded", function () {
      loadChatHistory();
      setInterval(loadChatHistory, 2000);
    });
  </script>


  <audio id="remoteAudio" autoplay playsinline muted="false" style="display: none;"></audio>
  <audio id="translatedAudio" controls></audio>
  <input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const startCall = document.getElementById("startCall");
      const pickupBtn = document.getElementById("pickupBtn");
      const ringtone = document.getElementById("ringtone");
      const modalElement = document.getElementById("incomingCallModal");
      const modalEl = new bootstrap.Modal(modalElement);
      document.getElementById("stopCall").addEventListener("click", stopCall);

      let localStream = null;
      let latestOffer = null;
      let currentCallId = null;
      let callInProgress = false;
      let lastOfferId = null;
      let peerConnection = null;
      let micTrack = null;
      let tracks = null;
      let testStream = null;
      let textToBeSent = null;
      let receiver = "{{ receiver.id }}";
      function getCSRFToken() {
        return document.cookie.split("; ").find(row => row.startsWith("csrftoken="))?.split("=")[1];
      }

      async function prepareMicTrack() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const audioTracks = stream.getAudioTracks();

          if (!audioTracks || audioTracks.length === 0) {
            console.warn("âš ï¸ No audio tracks found");
            return;
          }

          micTrack = audioTracks[0];
          console.log("ðŸŽ¤ Mic track ready:", micTrack);
        } catch (err) {
          console.error("ðŸš« getUserMedia failed:", err);
        }
      }

      async function getCurrentUserId() {
        try {
          const response = await fetch("/api/me", { credentials: "include" });
          if (!response.ok) return null;
          const data = await response.json();
          return data.id;
        } catch (err) {
          console.error("âŒ Failed to get current user:", err);
          return null;
        }
      }

      function setupPeerConnection() {
        const pc = new RTCPeerConnection({
          iceServers: [{ urls: "stun:stun.l.google.com:19302" },
          {
            urls: "turn:relay.example.com:3478",
            username: "user",
            credential: "pass"
          }
          ]
        });
        // ðŸ”„ Monitor connection state
        pc.onconnectionstatechange = () => {
          console.log("ðŸ”„ Connection state:", pc.connectionState);
        };

        // ðŸ§Š ICE connection status
        pc.oniceconnectionstatechange = () => {
          console.log("ðŸ§Š ICE state:", pc.iceConnectionState);
        };

        // ðŸ“¡ ICE gathering status
        pc.onicegatheringstatechange = () => {
        };

        // â„ï¸ ICE candidate logs
        pc.onicecandidate = (event) => {
          if (event.candidate) {
            console.log("â„ï¸ ICE candidate:", event.candidate.candidate);
          } else {
            //console.log("âœ… ICE gathering complete");
          }
        };

        pc.ontrack = (event) => {
          // Log track state immediately
          console.log("ðŸŽ™ï¸ Incoming track:", event.track.kind);
          console.log("ðŸ”Ž Track muted:", event.track.muted, "| enabled:", event.track.enabled);


          if (!event.streams || event.streams.length === 0) {
            console.warn("âš ï¸ No streams in ontrack event");
            const fallbackStream = new MediaStream([event.track]);
            const remoteAudio = document.getElementById("remoteAudio");
            remoteAudio.srcObject = fallbackStream;
            remoteAudio.muted = false;
            remoteAudio.play().catch(err => {
              console.warn("ðŸ”‡ Autoplay blocked:", err);
            });
            return;
          }

          // âœ… Normal path when streams are present
          const remoteStream = new MediaStream();
          event.streams[0].getAudioTracks().forEach(track => {
            remoteStream.addTrack(track);
            console.log("ðŸŽ§ Track received:", track.id, "| enabled:", track.enabled, "| muted:", track.muted);
          });

          const remoteAudio = document.getElementById("remoteAudio");
          remoteAudio.srcObject = remoteStream;
          remoteAudio.muted = false;
          remoteAudio.play().then(() => {
            console.log("ðŸ”Š Remote audio playing");
          }).catch(err => {
            console.warn("ðŸ”‡ Autoplay blocked:", err);
          });
        };

        pc.onicecandidate = (event) => {
          if (event.candidate) {
            //console.log("ðŸ§Š ICE candidate:", event.candidate);
          }
        };

        pc.onconnectionstatechange = () => {
          console.log("ðŸ”„ Connection state:", pc.connectionState);
        };

        return pc;
      }

      startCall.onclick = async () => {
        try {
          const callerId = await getCurrentUserId();
          if (!callerId) return alert("Unable to identify caller.");

          const selectedCard = document.querySelector('.user-card.selected');
          if (!selectedCard) return alert("Please select a user to call.");

          const receiverId = selectedCard.dataset.userid;

          // Prepare local audio stream
          const localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

          // Set up peer connection
          peerConnection = setupPeerConnection();

          // Add tracks to connection and log them
          localStream.getAudioTracks().forEach(track => {
            peerConnection.addTrack(track, localStream);
            console.log("ðŸ“¡ Caller sending track:", track.id, "| muted:", track.muted);
          });

          // Optional test stream for debugging
          const testStream = new MediaStream([localStream.getAudioTracks()[0]]);
          console.log("ðŸŽ¤ Mic stream prepared:", testStream);

          // Create and send SDP offer
          const offer = await peerConnection.createOffer();
          await peerConnection.setLocalDescription(offer);

          const response = await fetch("/api/call/start", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": getCSRFToken()
            },
            body: JSON.stringify({
              caller: callerId,
              receiver: receiverId,
              sdp_offer: JSON.stringify(offer)
            })
          });

          const data = await response.json();
          currentCallId = data.id;
          console.log("ðŸ“¡ Outgoing call ID:", currentCallId);

        } catch (err) {
          console.error("Error starting call:", err);
        }
      };

      setInterval(async () => {
        if (callInProgress) return;

        try {
          const currentUserId = await getCurrentUserId();
          if (!currentUserId) return;

          const res = await fetch(`/api/call/offer?for_user=${currentUserId}`);

          if (res.status !== 200) return;

          const data = await res.json();

          if (!data?.sdp_offer || !data.id || data.sdp_offer === "test-offer") return;
          if (data.id === lastOfferId) return;

          lastOfferId = data.id;
          currentCallId = data.id;
          latestOffer = data.sdp_offer;
          callInProgress = true;

          modalEl.show();
          modalEl.setAttribute("aria-hidden", "false");
          ringtone?.play().catch(() => { });
          pickupBtn.focus();

        } catch (err) {
          console.error("Polling error:", err);
        }
      }, 5000);

      let recorder = null;

      async function startRecording() {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const mimeType = [
          "audio/webm;codecs=opus",
          "audio/webm",         // fallback
          "audio/ogg;codecs=opus"
        ].find(type => MediaRecorder.isTypeSupported(type));

        if (!mimeType) {
          alert("No supported audio format found for MediaRecorder");
          return;
        }

        recorder = new MediaRecorder(stream, { mimeType });
        recorder.ondataavailable = e => {
          if (e.data.size > 0) chunks.push(e.data);
        };
        chunks = [];
        recorder.onstop = () => {
          const blob = new Blob(chunks, { type: mimeType });

          uploadAudio(blob);
        };
        recorder.start();
      }

      pickupBtn.onclick = async () => {
        try {
          await startRecording();

          setTimeout(() => {
            if (recorder && recorder.state === "recording") {
              recorder.stop();
              console.log("Recording stopped.");
            }
          }, 5000);
          const popupEl = document.getElementById("incomingCallModal");
          const modalInstance = bootstrap.Modal.getInstance(popupEl);
          if (modalInstance) {
            modalInstance.hide();
          } else {
            popupEl.style.display = "none";
          }

          const inputEl = document.getElementById("messageInput");
          if (inputEl) inputEl.focus();

        } catch (err) {
          console.error("Pickup failed:", err);
        }
      };

      function uploadAudio(blob) {

        //console.log("In uploadAudio...");
        const formData = new FormData();
        formData.append("audio", blob, "speech.ogg");
        //console.log(" Uploading Audio...");
        fetch("/translate-audio/", {
          method: "POST",
          body: formData
        })
          .then(res => res.json())
          .then(data => {
            console.log("Transcribed:", data.transcribed);
            console.log("Translated:", data.translated);
            console.log("audio_url:", data.audio_url);
            textToBeSent = data.translated;
            const audio = new Audio(data.audio_url);
            audio.play();
            console.log("Translated YYY:", textToBeSent);
            saveMessageAJAX()
          })
          .catch(err => console.error("Upload failed:", err));
      }

      function saveMessageAJAX() {
        const message = textToBeSent.trim();
        const receiverId = "{{ receiver.id }}";

        if (!message) return;

        fetch("/api/chat/save/", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": document.querySelector('[name=csrfmiddlewaretoken]').value
          },
          body: JSON.stringify({
            receiver_id: receiverId,
            message: message
          })
        })
          .then(response => response.json())
          .then(data => {
            if (data.status === "Message saved") {
              console.log("Message saved:", data);
              messageInput.value = "";
              loadChatHistory();
            } else {
              console.error("Error:", data.error);
            }
          })
          .catch(error => console.error("Request failed:", error));
      }

      document.addEventListener("DOMContentLoaded", function () {
        document.getElementById("sendMessage").addEventListener("click", saveMessageAJAX);
      });
      function sendTranlatedtextToUser() {
        //console.log("Translated XXX:", textToBeSent);
        let userId = "{{ receiver.id }}"
        //const messageInput = document.getElementById("message");
        const message = textToBeSent.trim();
        console.log("userId :", userId);
        if (message !== "") {
          fetch("/api/chat/send/", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ "room_name": "{{ userId }}", "message": message })
          })
            .then(response => response.json())
            .then(data => {
              console.log("data.status :", data.status);
              messageInput.value = "";  // Clear input after sending
            });
        }
        console.log("message XXX:", message);
      }

      document.body.addEventListener("click", () => {
        if (micTrack instanceof MediaStreamTrack) {
          const testStream = new MediaStream([micTrack]); // âœ… No TypeError

          const audio = document.createElement("audio");
          audio.srcObject = testStream;
          audio.autoplay = true;
          audio.playsInline = true;
          audio.volume = 1.0;
          document.body.appendChild(audio);

          console.log("Mic playback triggered");
        } else {
          console.warn("Mic track is invalid or not yet ready");
        }
      }, { once: true }); // Runs only once to avoid re-adding audio

      function stopCall() {
        console.log("Stopping call...");

        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
        }

        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }

        if (recorder && recorder.stop) {
          recorder.stop();
          recorder = null;
        }

        document.getElementById("stopCall").style.display = "none";
        document.querySelectorAll('.user-card').forEach(card =>
          card.classList.remove('selected')
        );
        const ringtone = document.getElementById("ringtone");
        if (ringtone) ringtone.pause();

        const remoteAudio = document.getElementById("remoteAudio");
        if (remoteAudio) remoteAudio.srcObject = null;
      }
    });

  </script>
  <script>
    function selectUser(button) {
      document.querySelectorAll('.user-card').forEach(card =>
        card.classList.remove('selected')
      );

      const card = button.closest('.user-card');
      if (card) {
        card.classList.add('selected');
      } else {
        console.warn("Could not find user-card for clicked button");
      }
    }

    function selectAndStartCall(button) {
      selectUser(button);

      const startCallBtn = document.getElementById("startCall");
      if (startCallBtn) {
        startCallBtn.click();
      } else {
        console.warn("Start Call button not found in DOM");
      }
    }

    document.getElementById("startMeetingBtn").addEventListener("click", () => {
      const roomName = `room_${Date.now()}`;
      const receiverId = "{{ receiver.id }}";

      fetch("/api/send-meeting-invite/", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ room: roomName, target: receiverId })
      }).then(() => {
        window.location.href = `/meeting/${roomName}/`;
      });
    });
    // document.getElementById("startMeetingBtn").addEventListener("click", () => {
    //   // You can generate a room name based on timestamp or user ID
    //   const roomName = `room_${Date.now()}`;  // Or use a UUID or group ID
    //   const receiverId = "{{ receiver.id }}";  // From Django context
    //   const senderName = "{{ request.user.username }}";

    //   const chatSocket = new WebSocket(
    //     `ws://${window.location.host}/ws/chat/${receiverId}/`
    //   );
    //   // Send invite via WebSocket
    //   chatSocket.onopen = () => {
    //     chatSocket.send(JSON.stringify({
    //       type: "meeting_invite",
    //       room: roomName,
    //       sender: senderName,
    //       target: receiverId
    //     }));

    //     // Redirect initiator to meeting room
    //     window.location.href = `/meeting/${roomName}/`;
    //   };
    // });

  </script>
</body>

</html>